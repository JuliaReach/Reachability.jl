<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Algorithms · Reachability.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Reachability.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../interface/">User interface</a></li><li><a class="toctext" href="../systems/">Systems</a></li><li class="current"><a class="toctext" href>Algorithms</a><ul class="internal"><li><a class="toctext" href="#Continuous-time-reachability-1">Continuous-time reachability</a></li></ul></li><li><a class="toctext" href="../properties/">Properties</a></li><li><a class="toctext" href="../transformations/">Transformations</a></li><li><a class="toctext" href="../discretize/">Discretization</a></li><li><a class="toctext" href="../distributed/">Distributed computations</a></li></ul></li><li><a class="toctext" href="../../publications/">Publications</a></li><li><a class="toctext" href="../../citations/">Citations</a></li><li><a class="toctext" href="../../about/">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href>Algorithms</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/Reachability.jl/blob/master/docs/src/lib/algorithms.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Algorithms</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Available-Algorithms-1" href="#Available-Algorithms-1">Available Algorithms</a></h1><p>This section of the manual describes the algorithms that are available in this package.</p><ul><li><a href="../interface/#User-interface-1">User interface</a></li><ul><li><a href="../interface/#Posing-and-solving-a-reachability-problem-1">Posing and solving a reachability problem</a></li></ul></ul><h2><a class="nav-anchor" id="Continuous-time-reachability-1" href="#Continuous-time-reachability-1">Continuous-time reachability</a></h2><h3><a class="nav-anchor" id="Decomposition-based-approach-1" href="#Decomposition-based-approach-1">Decomposition-based approach</a></h3><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reachability.ReachSets.BFFPSV18" href="#Reachability.ReachSets.BFFPSV18"><code>Reachability.ReachSets.BFFPSV18</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">BFFPSV18 &lt;: ContinuousPost</code></pre><p>Implementation of the reachability algorithm using decompositions from [1].</p><p>This algorithm applies to continuous affine ordinary differential equations of the form</p><pre><code class="language-none">    x&#39;(t) = Ax(t) + u(t),\qquad x(0) ∈ X0, u(t) ∈ U ∀ t ∈ [0, T],    (1)</code></pre><p>where <code>T</code> is the (finite) time horizon. The result of the algorithm is a sequence of sets <code>Xk</code> whose union overapproximates the exact flowpipe of (1). </p><p><strong>Fields</strong></p><ul><li><code>options</code> – an <code>Options</code> structure that holds the algorithm-specific options</li></ul><p>The following options are available:</p><pre><code class="language-julia">option :discretization of type String has default value &#39;forward&#39;; model for bloating/continuous time analysis
option :algorithm of type String has default value &#39;explicit&#39;; algorithm backend
option :δ of type Float64 with alias :sampling_time has default value &#39;0.01&#39;; time step
option :vars of type AbstractArray{Int64,1} has default value &#39;Int64[]&#39;; variables of interest; default: all variables
option :partition of type AbstractArray{#s117,1} where #s117&lt;:AbstractArray{Int64,1} has default value &#39;Array{Int64,1}[[]]&#39;; block partition; a block is represented by a vector containing its indices
option :sih_method of type String has default value &#39;concrete&#39;; method to compute the symmetric interval hull in discretization
option :exp_method of type String has default value &#39;base&#39;; method to compute the matrix exponential
option :assume_sparse of type Bool has default value &#39;false&#39;; use an analysis for sparse discretized matrices?
option :lazy_inputs_interval of type Union{Int64, Function} has default value &#39;getfield(Reachability.ReachSets, Symbol(&quot;##33#34&quot;))()&#39;; length of interval in which the inputs are handled as a lazy set (``-1`` for &#39;never&#39;); may generally also be a predicate over indices; the default corresponds to ``-1``
option :block_options of type Any has default value &#39;nothing&#39;; short hand to set &#39;:block_options_init&#39; and &#39;:block_options_iter&#39;
option :block_options_init of type Any has default value &#39;nothing&#39;; option for the approximation of the initial states (during decomposition)
option :block_options_iter of type Any has default value &#39;nothing&#39;; option for the approximation of the states ``X_k``, ``k&gt;0``
option :assume_homogeneous of type Bool has default value &#39;false&#39;; ignore dynamic inputs during the analysis?
option :eager_checking of type Bool has default value &#39;true&#39;; terminate as soon as property violation was detected?
</code></pre><p>See the <code>Notes</code> below for examples and an explanation of the options.</p><p><strong>Algorithm</strong></p><p>We refer to [1] for technical details.</p><p><strong>Notes</strong></p><p>The compositional approach offers a tradeoff between accuracy and performance, since one can choose different partitions and different set representations.</p><p>These notes illustrate the options that can be passed to the solver. We begin by explaining the default options used by the algorithm. Then we show how to specify the computation of a subset of the flowpipe, which helps to improve performance, specially for large systems.</p><p>We continue to show some lower-level options such as how to specify a custom block decomposition (the set types used and the sizes of the blocks). </p><p>We conclude showing that there are two different <em>modes</em> of operation: flowpipe computation and safety property checking, and examples of use.</p><p><strong>Running example and default options</strong></p><p>By default, <code>BFFPSV18</code> uses a uniform partition of dimension <em>one</em> over all variables.</p><p>For example, consider the two-dimensional example from [2]:</p><pre><code class="language-julia-repl">julia&gt; using Reachability, MathematicalSystems

julia&gt; A = [-1  -4   0  0   0;
             4  -1   0  0   0;
             0   0  -3  1   0;
             0   0  -1  3   0;
             0   0   0  0  -2]

julia&gt; X₀ = BallInf(ones(5), 0.1);

juoia&gt; problem = InitialValueProblem(LinearContinuousSystem(A), X₀);

julia&gt; sol = solve(problem, Options(:T=&gt;5.0), op=BFFPSV18(Options(:δ=&gt;0.04)));</code></pre><p>Let&#39;s check that the dimension of the first set computed is 5:</p><pre><code class="language-julia-repl">julia&gt; dim(first(sol.Xk).X)
5

julia&gt; sol.options[:partition]
5-element Array{Array{Int64,1},1}:
 [1]
 [2]
 [3]
 [4]
 [5]</code></pre><p>Here, <code>[1]</code> corresponds to a block of size one for variable <code>5</code>, etc., until variable <code>5</code>. Let&#39;s check the set type used is interval:</p><pre><code class="language-julia-repl">julia&gt; sol.options[:set_type]
Interval

julia&gt; all([Xi isa Interval for Xi in array(first(sol.Xk).X)])
true</code></pre><p><strong>Specifying a subset of all variables</strong></p><p>Suppose that we are only interested in variables <code>1</code> and <code>2</code>. Then we can specify it using the <code>:vars</code> option:</p><pre><code class="language-julia-repl">julia&gt; sol = solve(problem, Options(:T=&gt;5.0), op=BFFPSV18(Options(:δ=&gt;0.04, :vars=&gt;[1,2])));

julia&gt; dim(first(sol.Xk).X)
2</code></pre><p>The sets used are intevals:</p><pre><code class="language-julia-repl">julia&gt; all([Xi isa Hyperrectangle for Xi in first(sol.Xk).X.array])
true</code></pre><p><strong>Specifying the set type</strong></p><p>We can as well specify using other set types for the overapproximation of the flowpipe, such as hyperrectangles. It can be specified using the <code>:overapproximation</code> option:</p><pre><code class="language-julia-repl">julia&gt; sol = solve(problem, Options(:T=&gt;5.0),
                   op=BFFPSV18(Options(:δ=&gt;0.04, :vars=&gt;[1,2], :set_type=&gt;Hyperrectangle)));

julia&gt; first(sol.Xk).X.array isa Hyperrectangle
true</code></pre><p>To increase the accuracy, the <code>overapproximation</code> option offers other possibilities. For example, one can use template directions instead of a fixed set type. Below we use octagonal directions:</p><pre><code class="language-julia-repl">julia&gt; sol = solve(problem, Options(:T=&gt;5.0),
                   op=BFFPSV18(Options(:δ=&gt;0.04, :vars=&gt;[1,2], :template_directions=&gt;:oct)));

julia&gt; first(sol.Xk).X.array isa HPolygon # CHECK: are these polygons or polytopes?
true</code></pre><p>Another possibility is to use epsilon-close approximation using polygons:</p><pre><code class="language-julia-repl">julia&gt; sol = solve(problem, Options(:T=&gt;5.0),
                   op=BFFPSV18(Options(:δ=&gt;0.04, :vars=&gt;[1,2], :set_type=&gt;HPolygon, :ε=&gt;1e-3)));

julia&gt; first(sol.Xk).X.array isa HPolygon
true</code></pre><p>In this case, the overapproximation option can be ommited. The previous options are equivalent to:</p><pre><code class="language-julia-repl">julia&gt; sol = solve(problem, Options(:T=&gt;5.0),
                   op=BFFPSV18(Options(:δ=&gt;0.04, :vars=&gt;[1,2], :ε=&gt;1e-3)));

julia&gt; first(sol.Xk).X.array isa HPolygon
true</code></pre><p><strong>Different decomposition strategies at different stages</strong></p><p><strong>References</strong></p><p>[1] <a href="https://dl.acm.org/citation.cfm?id=3178128">Reach Set Approximation through Decomposition with Low-dimensional Sets and High-dimensional Matrices</a>. S. Bogomolov, M. Forets, G. Frehse, A. Podelski, C. Schilling, F. Viry. HSCC &#39;18 Proceedings of the 21st International Conference on Hybrid Systems: Computation and Control (part of CPS Week).</p><p>[2] Althoff, Matthias. Reachability analysis and its application to the safety assessment of autonomous cars. Diss. Technische Universität München, 2010.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/Reachability.jl/blob/bddd0e372fd4a533bbe5b0dcedc04603cdcd18fc/src/ReachSets/ContinuousPost/BFFPSV18/BFFPSV18.jl#L140-L311">source</a></section><footer><hr/><a class="previous" href="../systems/"><span class="direction">Previous</span><span class="title">Systems</span></a><a class="next" href="../properties/"><span class="direction">Next</span><span class="title">Properties</span></a></footer></article></body></html>
