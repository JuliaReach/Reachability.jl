<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Discretization ¬∑ Reachability.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../assets/juliareach.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Reachability.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="interface.html">User interface</a></li><li><a class="toctext" href="systems.html">Systems</a></li><li><a class="toctext" href="algorithms.html">Algorithms</a></li><li><a class="toctext" href="properties.html">Properties</a></li><li><a class="toctext" href="transformations.html">Transformations</a></li><li class="current"><a class="toctext" href="discretize.html">Discretization</a><ul class="internal"></ul></li><li><a class="toctext" href="distributed.html">Distributed computations</a></li></ul></li><li><a class="toctext" href="../publications.html">Publications</a></li><li><a class="toctext" href="../citations.html">Citations</a></li><li><a class="toctext" href="../about.html">About</a></li></ul></nav><article id="docs"><header><nav><ul><li>Library</li><li><a href="discretize.html">Discretization</a></li></ul><a class="edit-page" href="https://github.com/JuliaReach/Reachability.jl/blob/master/docs/src/lib/discretize.md"><span class="fa">ÔÇõ</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Discretization</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Discretize-1" href="#Discretize-1">Discretize</a></h1><ul><li><a href="discretize.html#Discretize-1">Discretize</a></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reachability.ReachSets.discretize" href="#Reachability.ReachSets.discretize"><code>Reachability.ReachSets.discretize</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">discretize(ùëÜ, Œ¥; [algorithm], [exp_method], [sih_method], [set_operations])</code></pre><p>Apply an approximation model to <code>S</code> obtaining a discrete initial value problem.</p><p><strong>Input</strong></p><ul><li><p><code>ùëÜ</code>             ‚Äì initial value problem for a continuous affine ODE with                    non-deterministic inputs</p></li><li><p><code>Œ¥</code>             ‚Äì step size</p></li><li><p><code>algorithm</code>     ‚Äì (optional, default: <code>&quot;forward&quot;</code>) the algorithm used to                    compute the approximation model for the discretization,                    choose among:</p><ul><li><code>&quot;forward&quot;</code>    ‚Äì use forward-time interpolation</li><li><code>&quot;backward&quot;</code>   ‚Äì use backward-time interpolation</li><li><code>&quot;firstorder&quot;</code> ‚Äì use first-order approximation of the ODE</li><li><code>&quot;nobloating&quot;</code> ‚Äì do not bloat the initial states</li></ul></li><li><p><code>exp_method</code>  ‚Äì (optional, default: <code>&quot;base&quot;</code>) the method used to take the matrix                   exponential of the coefficient matrix, choose among:</p><ul><li><code>&quot;base&quot;</code> ‚Äì the scaling and squaring method implemented in Julia base,             see <code>?exp</code> for details</li><li><code>&quot;pade&quot;</code> ‚Äì use Pade approximant method to compute matrix exponentials of             sparse matrices, implemented in <code>Expokit</code></li><li><code>&quot;lazy&quot;</code> ‚Äì compute a wrapper type around the matrix exponential, i.e. using             the lazy implementation <code>SparseMatrixExp</code> from <code>LazySets</code> and             the evaluation of the action of the matrix exponential using the             <code>expmv</code> implementation from <code>Expokit</code></li></ul></li><li><p><code>sih_method</code>  ‚Äì (optional, default: <code>&quot;concrete&quot;</code>) the method used to take the                   symmetric interval hull operation, choose among:</p><ul><li><code>&quot;concrete&quot;</code> ‚Äì compute the full symmetric interval hull using the function                 <code>symmetric_interval_hull</code> from <code>LazySets.Approximations</code></li><li><code>&quot;lazy&quot;</code>     ‚Äì compute a wrapper set type around symmetric interval hull                 in a lazy way using <code>SymmetricIntervalHull</code></li></ul></li><li><p><code>set_operations</code>  ‚Äì (optional, default: <code>&quot;lazy&quot;</code>) set operations used for the                      discretized initial states and transformed inputs, choose among:</p><ul><li><code>&quot;lazy&quot;</code>     ‚Äì use lazy convex hull for the initial states and lazy linear                 map for the inputs</li><li><code>&quot;zonotope&quot;</code> ‚Äì use concrete zonotope operations (linear map and Minkowski sum)                 and return zonotopes for both the initial states and the                 inputs of the discretized system</li></ul></li></ul><p><strong>Output</strong></p><p>The initial value problem of a discrete system.</p><p><strong>Algorithm</strong></p><p>Let <span>$ùëÜ : x&#39; = Ax(t) + u(t)$</span>, <span>$x(0) ‚àà \mathcal{X}_0$</span>, <span>$u(t) ‚àà U$</span> be the given continuous affine ODE <code>ùëÜ</code>, where <code>U</code> is the set of non-deterministic inputs and <span>$\mathcal{X}_0$</span> is the set of initial states. Recall that the system <code>ùëÜ</code> is called homogeneous whenever <code>U</code> is the empty set.</p><p>Given a step size <span>$Œ¥$</span>, this function computes a set, <code>Œ©‚ÇÄ</code>, that guarantees to contain all the trajectories of <span>$ùëÜ$</span> starting at any <span>$x(0) ‚àà \mathcal{X}_0$</span> and for any input function that satisfies <span>$u(t) ‚àà U$</span>, for any <span>$t ‚àà [0, Œ¥]$</span>.</p><p>The initial value problem returned by this function consists of the set <code>Œ©‚ÇÄ</code> together with the coefficient matrix <span>$œï = e^{AŒ¥}$</span> and a transformed set of inputs if <code>U</code> is non-empty.</p><p>In the literature, the method to obtain <code>Œ©‚ÇÄ</code> is called the <em>approximation model</em> and different alternatives have been proposed. See the argument <code>algorithm</code> for available options. For the reference to the original papers, see the docstring of each method <code>discretize_...</code>.</p><p>In the dense-time case, the transformation is such that the trajectories of the given continuous system are included in the computed flowpipe of the discretized system.</p><p>In the discrete-time case, there is no bloating of the initial states and the input is assumed to remain constant between sampled times. Use the option <code>algorithm=&quot;nobloating&quot;</code> for this setting.</p><p>Several methods to compute the matrix exponential are availabe. Use <code>exp_method</code> to select one. For very large systems, computing the full matrix exponential is expensive hence it is preferable to compute the action of the matrix exponential over vectors when needed, <code>e^{Œ¥A} v</code> for each <code>v</code>. Use the option <code>exp_method=&quot;lazy&quot;</code> for this purpose.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/Reachability.jl/blob/87c0e31b514c0c5b77c2165db9359df097330df6/src/ReachSets/discretize.jl#L1-L86">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reachability.ReachSets.discretize_interpolation" href="#Reachability.ReachSets.discretize_interpolation"><code>Reachability.ReachSets.discretize_interpolation</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">discretize_interpolation(ùëÜ, Œ¥; [algorithm], [exp_method], [sih_method])</code></pre><p>Compute bloating factors using forward or backward interpolation.</p><p><strong>Input</strong></p><ul><li><p><code>ùëÜ</code>             ‚Äì a continuous system</p></li><li><p><code>Œ¥</code>             ‚Äì step size</p></li><li><p><code>algorithm</code>     ‚Äì choose the algorithm to compute the approximation model                    among <code>&quot;forward&quot;</code> and <code>&quot;backward&quot;</code></p></li><li><p><code>exp_method</code>    ‚Äì (optional, default: <code>&quot;base&quot;</code>) the method used to take the matrix                    exponential of the coefficient matrix, choose among:</p><ul><li><code>&quot;base&quot;</code> ‚Äì the scaling and squaring method implemented in Julia base,             see <code>?exp</code> for details</li><li><code>&quot;pade&quot;</code> ‚Äì use Pade approximant method to compute matrix exponentials of             sparse matrices, implemented in <code>Expokit</code></li><li><code>&quot;lazy&quot;</code> ‚Äì compute a wrapper type around the matrix exponential, i.e. using             the lazy implementation <code>SparseMatrixExp</code> from <code>LazySets</code> and             the evaluation of the action of the matrix exponential using the             <code>expmv</code> implementation from <code>Expokit</code></li></ul></li><li><p><code>sih_method</code>    ‚Äì (optional, default: <code>&quot;concrete&quot;</code>) the method used to take the                    symmetric interval hull operation, choose among:</p><ul><li><code>&quot;concrete&quot;</code> ‚Äì compute the full symmetric interval hull</li><li><code>&quot;lazy&quot;</code>     ‚Äì compute a wrapper set type around symmetric interval hull in a                 lazy way</li></ul></li></ul><p><strong>Output</strong></p><p>The initial value problem for a discrete system. In particular:</p><ul><li>if the input system is homogeneous, a <code>LinearDiscreteSystem</code> is returned,</li><li>otherwise a <code>ConstrainedLinearControlDiscreteSystem</code> is returned.</li></ul><p><strong>Algorithm</strong></p><p>Let us define some notation. Let</p><div>\[ùëÜ : x&#39; = Ax(t) + u(t)\]</div><p>with <span>$x(0) ‚àà \mathcal{X}_0$</span>, <span>$u(t) ‚àà U$</span> be the given continuous affine ODE <code>ùëÜ</code>, where <code>U</code> is the set of non-deterministic inputs and <span>$\mathcal{X}_0$</span> is the set of initial states.</p><p>The transformations are:</p><ul><li><span>$Œ¶ ‚Üê \exp^{AŒ¥}$</span>,</li><li><span>$Œ©‚ÇÄ ‚Üê ConvexHull(\mathcal{X}_0, Œ¶\mathcal{X}_0 ‚äï Œ¥U(0) ‚äï Eœà(U(0), Œ¥) ‚äï E^+(\mathcal{X}_0, Œ¥))$</span>,</li><li><span>$V ‚Üê Œ¥U(k) ‚äï Eœà(U(k), Œ¥)$</span>.</li></ul><p>Here we allow <span>$U$</span> to be a sequence of time varying non-deterministic input sets.</p><p>For the definition of the sets <span>$Eœà$</span> and <span>$E^+$</span> see [1]. The  &quot;backward&quot; method uses <span>$E^-$</span>.</p><p>[1] Frehse, Goran, et al. &quot;SpaceEx: Scalable verification of hybrid systems.&quot; International Conference on Computer Aided Verification. Springer, Berlin, Heidelberg, 2011.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/Reachability.jl/blob/87c0e31b514c0c5b77c2165db9359df097330df6/src/ReachSets/discretize.jl#L544-L606">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reachability.ReachSets.discretize_firstorder" href="#Reachability.ReachSets.discretize_firstorder"><code>Reachability.ReachSets.discretize_firstorder</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">discretize_firstorder(ùëÜ, Œ¥; [p], [exp_method])</code></pre><p>Apply a first-order approximation model to <code>S</code> obtaining a discrete initial value problem.</p><p><strong>Input</strong></p><ul><li><p><code>ùëÜ</code>           ‚Äì initial value problem for a continuous affine ODE with                  non-deterministic inputs</p></li><li><p><code>Œ¥</code>           ‚Äì step size</p></li><li><p><code>p</code>           ‚Äì (optional, default: <code>Inf</code>) parameter in the considered norm</p></li><li><p><code>exp_method</code>  ‚Äì (optional, default: <code>&quot;base&quot;</code>) the method used to take the matrix                   exponential of the coefficient matrix, choose among:</p><ul><li><code>&quot;base&quot;</code> ‚Äì the scaling and squaring method implemented in Julia base,             see <code>?exp</code> for details</li><li><code>&quot;pade&quot;</code> ‚Äì use Pade approximant method to compute matrix exponentials of             sparse matrices, implemented in <code>Expokit</code></li><li><code>&quot;lazy&quot;</code> ‚Äì compute a wrapper type around the matrix exponential, i.e. using             the lazy implementation <code>SparseMatrixExp</code> from <code>LazySets</code> and             the evaluation of the action of the matrix exponential using the             <code>expmv</code> implementation from <code>Expokit</code></li></ul></li></ul><p><strong>Output</strong></p><p>The initial value problem for a discrete system. In particular:</p><ul><li>if the input system is homogeneous, a <code>LinearDiscreteSystem</code> is returned,</li><li>otherwise a <code>ConstrainedLinearControlDiscreteSystem</code> is returned.</li></ul><p><strong>Algorithm</strong></p><p>Let us define some notation. Let</p><div>\[ùëÜ : x&#39; = Ax(t) + u(t)\]</div><p>with <span>$x(0) ‚àà \mathcal{X}_0$</span>, <span>$u(t) ‚àà U$</span> be the given continuous affine ODE <code>ùëÜ</code>, where <code>U</code> is the set of non-deterministic inputs and <span>$\mathcal{X}_0$</span> is the set of initial states.</p><p>Define <span>$R_{\mathcal{X}_0} = \max_{x ‚àà \mathcal{X}_0} ‚Äñx‚Äñ$</span>, <code>D_{\mathcal{X}_0} = \max_{x, y ‚àà \mathcal{X}_0} ‚Äñx-y‚Äñ</code><code>and</code><code>R_{U} = \max_{u ‚àà U} ‚Äñu‚Äñ</code><code>. If only the support functions of</code><code>\mathcal{X}_0</code><code>and</code><code>U</code><code>are known, these values might be hard to compute for some norms. See</code>Notes` below for details.</p><p>Let <span>$Œ©‚ÇÄ$</span> be the set defined as:</p><div>\[Œ©‚ÇÄ = ConvexHull(\mathcal{X}_0, e^{Œ¥A}\mathcal{X}_0 ‚äï Œ¥U ‚äï Œ±B_p)\]</div><p>where <span>$Œ± = (e^{Œ¥ ‚ÄñA‚Äñ} - 1 - Œ¥‚ÄñA‚Äñ)*(R_{\mathcal{X}_0} + R_{U} / ‚ÄñA‚Äñ)$</span> and <span>$B_p$</span> denotes the unit ball for the considered <span>$p$</span>-norm.</p><p>It is proved in [Lemma 1, 1] that the set of states reachable by <span>$S$</span> in the time interval <span>$[0, Œ¥]$</span>, which we denote <span>$R_{[0,Œ¥]}(\mathcal{X}_0)$</span> here, is included in <span>$Œ©‚ÇÄ$</span>:</p><div>\[R_{[0,Œ¥]}(\mathcal{X}_0) ‚äÜ Œ©‚ÇÄ.\]</div><p>Moreover, if <span>$d_H(A, B)$</span> denotes the Hausdorff distance between the sets <span>$A$</span> and <span>$B$</span> in <span>$\mathbb{R}^n$</span>, then</p><div>\[d_H(Œ©‚ÇÄ, R_{[0,Œ¥]}(\mathcal{X}_0)) ‚â§ \frac{1}{4}(e^{Œ¥ ‚ÄñA‚Äñ} - 1) D_{\mathcal{X}_0} + 2Œ±.\]</div><p>Hence, the approximation error can be made arbitrarily small by choosing <span>$Œ¥$</span> small enough.</p><p>Here we allow <span>$U$</span> to be a sequence of time varying non-deterministic inputs.</p><p><strong>Notes</strong></p><p>In this implementation, the infinity norm is used by default. Other usual norms are <span>$p=1$</span> and <span>$p=2$</span>. However, note that not all norms are supported; see the documentation of <code>?norm</code> in <code>LazySets</code> for the supported norms.</p><p>See also <a href="discretize.html#Reachability.ReachSets.discretize_interpolation"><code>discretize_interpolation</code></a> for an alternative algorithm that uses less conservative bounds.</p><p>[1] Le Guernic, C., &amp; Girard, A., 2010, <em>Reachability analysis of linear systems using support functions. Nonlinear Analysis: Hybrid Systems, 4(2), 250-262.</em></p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/Reachability.jl/blob/87c0e31b514c0c5b77c2165db9359df097330df6/src/ReachSets/discretize.jl#L306-L391">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Reachability.ReachSets.discretize_nobloating" href="#Reachability.ReachSets.discretize_nobloating"><code>Reachability.ReachSets.discretize_nobloating</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">discretize_nobloating(ùëÜ, Œ¥; [exp_method])</code></pre><p>Discretize a continuous system without bloating of the initial states, suitable for discrete-time reachability.</p><p><strong>Input</strong></p><ul><li><p><code>ùëÜ</code>          ‚Äì a continuous system</p></li><li><p><code>Œ¥</code>          ‚Äì step size</p></li><li><p><code>exp_method</code> ‚Äì (optional, default: <code>&quot;base&quot;</code>) the method used to take the matrix                 exponential of the coefficient matrix, choose among:</p><ul><li><code>&quot;base&quot;</code> ‚Äì the scaling and squaring method implemented in Julia base,             see <code>?exp</code> for details</li><li><code>&quot;pade&quot;</code> ‚Äì use Pade approximant method to compute matrix exponentials of             sparse matrices, implemented in <code>Expokit</code></li><li><code>&quot;lazy&quot;</code> ‚Äì compute a wrapper type around the matrix exponential, i.e. using             the lazy implementation <code>SparseMatrixExp</code> from <code>LazySets</code> and             the evaluation of the action of the matrix exponential using the             <code>expmv</code> implementation from <code>Expokit</code></li></ul></li></ul><p><strong>Output</strong></p><p>The initial value problem for a discrete system. In particular:</p><ul><li>if the input system is homogeneous, a <code>LinearDiscreteSystem</code> is returned,</li><li>otherwise a <code>ConstrainedLinearControlDiscreteSystem</code> is returned.</li></ul><p><strong>Algorithm</strong></p><p>Let us define some notation. Let</p><div>\[ùëÜ : x&#39; = Ax(t) + u(t)\]</div><p>with <span>$x(0) ‚àà \mathcal{X}_0$</span>, <span>$u(t) ‚àà U$</span> be the given continuous affine ODE <code>ùëÜ</code>, where <code>U</code> is the set of non-deterministic inputs and <span>$\mathcal{X}_0$</span> is the set of initial states.</p><p>The approximation model implemented in this function is such that there is no bloating, i.e. we don&#39;t bloat the initial states and don&#39;t multiply the input by the step size Œ¥, as required for the dense time case.</p><p>The transformations are:</p><ul><li><span>$Œ¶ ‚Üê \exp^{AŒ¥}$</span></li><li><span>$Œ©‚ÇÄ ‚Üê \mathcal{X}_0$</span></li><li><span>$V ‚Üê Œ¶‚ÇÅ(A, Œ¥)U(k)$</span>, where <span>$Œ¶‚ÇÅ(A, Œ¥)$</span> is defined in <a href="lib/@ref"><code>Œ¶‚ÇÅ(A, Œ¥; [exp_method])</code></a>.</li></ul><p>Here we allow <span>$U$</span> to be a sequence of time varying non-deterministic input sets.</p></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaReach/Reachability.jl/blob/87c0e31b514c0c5b77c2165db9359df097330df6/src/ReachSets/discretize.jl#L464-L516">source</a></section><footer><hr/><a class="previous" href="transformations.html"><span class="direction">Previous</span><span class="title">Transformations</span></a><a class="next" href="distributed.html"><span class="direction">Next</span><span class="title">Distributed computations</span></a></footer></article></body></html>
