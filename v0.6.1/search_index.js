var documenterSearchIndex = {"docs":
[{"location":"publications/#Publications-1","page":"Publications","title":"Publications","text":"","category":"section"},{"location":"publications/#","page":"Publications","title":"Publications","text":"Pages = [\"publications.md\"]","category":"page"},{"location":"publications/#","page":"Publications","title":"Publications","text":"This page lists publications about the JuliaReach ecosystem and its applications.","category":"page"},{"location":"publications/#ARCH-2019-Competition-NLN-Category-Report-1","page":"Publications","title":"ARCH 2019 Competition NLN Category Report","text":"","category":"section"},{"location":"publications/#","page":"Publications","title":"Publications","text":"ARCH-COMP19 Category Report: Continuous and Hybrid Systems with Nonlinear Dynamics. Fabian Immler, Matthias Althoff, Luis Benet, Alexandre Chapoutot, Xin Chen, Marcelo Forets, Luca Geretti, Niklas Kochdumper, David P. Sanders and Christian Schilling (2019) ARCH19. 6th International Workshop on Applied Verification of Continuous and Hybrid Systems, vol 61, pages 41‚Äì61 doi: 10.29007/bj1w. Packages: Reachability.jl.","category":"page"},{"location":"publications/#","page":"Publications","title":"Publications","text":"Abstract. We present the results of a friendly competition for formal verification of continuous and hybrid systems with nonlinear continuous dynamics. The friendly competition took place as part of the workshop Applied Verification for Continuous and Hybrid Systems (ARCH) in 2019. In this year, 6 tools Ariadne, CORA, DynIbex, Flow*, Isabelle/HOL, and JuliaReach (in alphabetic order) participated. They are applied to solve reachability analysis problems on four benchmark problems, one of them with hybrid dynamics. We do not rank the tools based on the results, but show the current status and discover the potential advantages of different tools.","category":"page"},{"location":"publications/#","page":"Publications","title":"Publications","text":"The repeatability evaluation package for JuliaReach is available at ARCH2019_RE.","category":"page"},{"location":"publications/#","page":"Publications","title":"Publications","text":"The repeatability evaluation packages of all tools participating in this report is available in the ARCH-COMP gitlab repo.","category":"page"},{"location":"publications/#","page":"Publications","title":"Publications","text":"JuliaReach is a toolbox for reachability computations of dynamical systems, available at http://juliareach.org. For nonlinear reachability we combine functionality from Taylor-Models.jl, TaylorSeries.jl and TaylorIntegration.jl. First, we compute a non-validated integration using a Taylor model of  order nT. The coefficients of that series are polynomials of ordern Q in the variables that denote the small variations of the initial conditions. We obtain a time step from the last two coefficients of this time series. In order to validate the  integration step, we compute a second integration using intervals as coefficients of the polynomials in time, and we obtain a bound for the integration using a Lagrange-like remainder. The remainder is used to check the contraction of a Picard iteration. If the combination of the time step and the remainder do not satisfy the contraction, we iteratively enlarge the remainder or possibly shrink the time step. Finally, we evaluate the initial Taylor series with the valid remainder at the time step for which the contraction has been proved, which is also evaluated in the initial box of deviations from the central initial condition, to yield an over-approximation. The approach is (numerically) sound due to rigorous interval bounds in the Taylor approximation.","category":"page"},{"location":"publications/#ARCH-2019-Competition-AFF-Category-Report-1","page":"Publications","title":"ARCH 2019 Competition AFF Category Report","text":"","category":"section"},{"location":"publications/#","page":"Publications","title":"Publications","text":"ARCH-COMP19 Category Report: Continuous and Hybrid Systems with Linear Continuous Dynamics. Matthias Althoff, Stanley Bak, Marcelo Forets, Goran Frehse, Niklas Kochdumper, Rajarshi Ray, Christian Schilling and Stefan Schupp (2019) ARCH19. 6th International Workshop on Applied Verification of Continuous and Hybrid Systems, vol 61, pages 14‚Äì40 doi: 10.29007/bj1w. Packages: Reachability.jl.","category":"page"},{"location":"publications/#","page":"Publications","title":"Publications","text":"Abstract. This report presents the results of a friendly competition for formal verification of continuous and hybrid systems with linear continuous dynamics. The friendly competition took place as part of the workshop Applied Verification for Continuous and Hybrid Systems (ARCH) in 2019. In its third edition, seven tools have been applied to solve six different benchmark problems in the category for linear continuous dynamics (in alphabetical order): CORA, CORA/SX, HyDRA, Hylaa, JuliaReach, SpaceEx, and XSpeed. This report is a snapshot of the current landscape of tools and the types of benchmarks they are particularly suited for. Due to the diversity of problems, we are not ranking tools, yet the presented results provide one of the most complete assessments of tools for the safety verification of continuous and hybrid systems with linear continuous dynamics up to this date.","category":"page"},{"location":"publications/#","page":"Publications","title":"Publications","text":"The repeatability evaluation package for JuliaReach is available at ARCH2019_RE.","category":"page"},{"location":"publications/#","page":"Publications","title":"Publications","text":"The repeatability evaluation packages of all tools participating in this report is available in the ARCH-COMP gitlab repo.","category":"page"},{"location":"publications/#Reachability-analysis-of-linear-hybrid-systems-via-block-decomposition-1","page":"Publications","title":"Reachability analysis of linear hybrid systems via block decomposition","text":"","category":"section"},{"location":"publications/#","page":"Publications","title":"Publications","text":"Reachability analysis of linear hybrid systems via block decomposition. Sergiy Bogomolov, Marcelo Forets, Goran Frehse, Kostiantyn Potomkin, Christian Schilling. Get pdf from arXiv: 1905.02458.","category":"page"},{"location":"publications/#","page":"Publications","title":"Publications","text":"Abstract. Reachability analysis aims at identifying states reachable by a system within a given time horizon. This task is known to be computationally hard for hybrid systems. One of the main challenges is the handling of discrete transitions, including computation of intersections with invariants and guards. In this paper, we address this problem by proposing a state-space decomposition approach for linear hybrid systems. This approach allows us to perform most operations in low-dimensional state space, which can lead to significant performance improvements.","category":"page"},{"location":"publications/#JuliaReach:-a-Toolbox-for-Set-Based-Reachability-1","page":"Publications","title":"JuliaReach: a Toolbox for Set-Based Reachability","text":"","category":"section"},{"location":"publications/#","page":"Publications","title":"Publications","text":"JuliaReach: a Toolbox for Set-Based Reachability. Sergiy Bogomolov, Marcelo Forets, Goran Frehse, Kostiantyn Potomkin, Christian Schilling. Published in Proceedings of HSCC'19: 22nd ACM International Conference on Hybrid Systems: Computation and Control (HSCC'19), see ACM link here. Get pdf from arXiv: 1901.10736.","category":"page"},{"location":"publications/#","page":"Publications","title":"Publications","text":"In 2019, this conference is part of the Cyber-Physical Systems and Internet-Of-Things Week.","category":"page"},{"location":"publications/#","page":"Publications","title":"Publications","text":"Abstract. We present JuliaReach, a toolbox for set-based reachability analysis of dynamical systems. JuliaReach consists of two main packages: Reachability, containing implementations of reachability algorithms for continuous and hybrid systems, and LazySets, a standalone library that implements state-of-the-art algorithms for calculus with convex sets. The library offers both concrete and lazy set representations, where the latter stands for the ability to delay set computations until they are needed. The choice of the programming language Julia and the accompanying documentation of our toolbox allow researchers to easily translate set-based algorithms from mathematics to software in a platform-independent way, while achieving runtime performance that is comparable to statically compiled languages. Combining lazy operations in high dimensions and explicit computations in low dimensions, JuliaReach can be applied to solve complex, large-scale problems.","category":"page"},{"location":"publications/#","page":"Publications","title":"Publications","text":"The repeatability evaluation package for this conference tool paper is available at HSCC2019_RE.","category":"page"},{"location":"publications/#ARCH-2018-Competition-AFF-Category-Report-1","page":"Publications","title":"ARCH 2018 Competition AFF Category Report","text":"","category":"section"},{"location":"publications/#","page":"Publications","title":"Publications","text":"ARCH-COMP18 Category Report: Continuous and Hybrid Systems with Linear Continuous Dynamics. Matthias Althoff, Stanley Bak, Xin Chen, Chuchu Fan,    Marcelo Forets, Goran Frehse, Niklas Kochdumper, Yangge Li, Sayan Mitra, Rajarshi Ray, Christian Schilling and Stefan Schupp (2018) ARCH18. 5th International Workshop on Applied Verification of Continuous and Hybrid Systems, 54: 23‚Äì52. doi: 10.29007/73mb. Packages: Reachability.jl.","category":"page"},{"location":"publications/#","page":"Publications","title":"Publications","text":"Abstract. This report presents the results of a friendly competition for formal verification of continuous and hybrid systems with linear continuous dynamics. The friendly competition took place as part of the workshop Applied Verification for Continuous and Hybrid Systems (ARCH) in 2018. In its second edition, 9 tools have been applied to solve six different benchmark problems in the category for linear continuous dynamics (in alphabetical order): CORA, CORA/SX, C2E2, FlowStar, HyDRA, Hylaa, Hylaa-Continuous, JuliaReach, SpaceEx, and XSpeed. This report is a snapshot of the current landscape of tools and the types of benchmarks they are particularly suited for. Due to the diversity of problems, we are not ranking tools, yet the presented results probably provide the most complete assessment of tools for the safety verification of continuous and hybrid systems with linear continuous dynamics up to this date.","category":"page"},{"location":"publications/#","page":"Publications","title":"Publications","text":"The repeatability evaluation package for JuliaReach is available at ARCH2018_RE.","category":"page"},{"location":"publications/#","page":"Publications","title":"Publications","text":"The repeatability evaluation packages of all tools participating in this report is available in the ARCH-COMP gitlab repo.","category":"page"},{"location":"publications/#Award-to-JuliaReach-1","page":"Publications","title":"Award to JuliaReach","text":"","category":"section"},{"location":"publications/#","page":"Publications","title":"Publications","text":"The Best Friendly Competition Result of the 2nd International Competition on Verifying Continuous and Hybrid Systems (ARCH) was given to JuliaReach for the results obtained in ARCH2018_RE for the affine category; see the announcement here:","category":"page"},{"location":"publications/#","page":"Publications","title":"Publications","text":"It is our pleasure to announce that Marcelo Forets and Christian Schilling receive the ARCH 2018 Best Friendly Competition Result. They develop the tool JuliaReach, which showed significant improvements for computing reachable sets of linear continuous systems. The award comes with a 500 Euro prize from Bosch. Goran Frehse received the prize from Thomas Heinz of Bosch on their behalf.","category":"page"},{"location":"publications/#Reach-Set-Approximation-through-Decomposition-1","page":"Publications","title":"Reach Set Approximation through Decomposition","text":"","category":"section"},{"location":"publications/#","page":"Publications","title":"Publications","text":"Reach Set Approximation through Decomposition with Low-dimensional Sets and High-dimensional Matrices. Sergiy Bogomolov, Marcelo Forets, Goran Frehse, Fr√©d√©ric Viry, Andreas Podelski and Christian Schilling (2018) HSCC'18 Proceedings of the 21st International Conference on Hybrid Systems: Computation and Control: 41‚Äì50. See the ACM Digital Library link, or the arXiv: 1801.09526. Packages: LazySets.jl and Reachability.jl. ","category":"page"},{"location":"publications/#","page":"Publications","title":"Publications","text":"Abstract. Approximating the set of reachable states of a dynamical system is an algorithmic yet mathematically rigorous way to reason about its safety. Although progress has been made in the development of efficient algorithms for affine dynamical systems, available algorithms still lack scalability to ensure their wide adoption in the industrial setting. While modern linear algebra packages are efficient for matrices with tens of thousands of dimensions, set-based image computations are limited to a few hundred. We propose to decompose reach set computations such that set operations are performed in low dimensions, while matrix operations like exponentiation are carried out in the full dimension. Our method is applicable both in dense- and discrete-time settings. For a set of standard benchmarks, it shows a speed-up of up to two orders of magnitude compared to the respective state-of-the art tools, with only modest losses in accuracy. For the dense-time case, we show an experiment with more than 10.000 variables, roughly two orders of magnitude higher than possible with previous approaches.","category":"page"},{"location":"publications/#","page":"Publications","title":"Publications","text":"For the models with the SLICOT benchmarks and the repeatability evaluation see ReachabilityBenchmarks.","category":"page"},{"location":"lib/interface/#User-interface-1","page":"User interface","title":"User interface","text":"","category":"section"},{"location":"lib/interface/#","page":"User interface","title":"User interface","text":"This section of the manual describes the main user interface.","category":"page"},{"location":"lib/interface/#","page":"User interface","title":"User interface","text":"Pages = [\"interface.md\"]","category":"page"},{"location":"lib/interface/#","page":"User interface","title":"User interface","text":"CurrentModule = Reachability","category":"page"},{"location":"lib/interface/#Posing-and-solving-a-reachability-problem-1","page":"User interface","title":"Posing and solving a reachability problem","text":"","category":"section"},{"location":"lib/interface/#","page":"User interface","title":"User interface","text":"A reachability problem is characterized by an AbstractSystem together with an Options structure.","category":"page"},{"location":"lib/interface/#","page":"User interface","title":"User interface","text":"solve","category":"page"},{"location":"lib/interface/#Reachability.solve","page":"User interface","title":"Reachability.solve","text":"solve(system, options)  or  solve(system, :key1 => val1, [...], keyK => valK)\n\nSolves a reachability problem s.t. the given options. If some options are not defined, we may fall back to default values.\n\nInput\n\nsystem    ‚Äì a (discrete or continuoues) system specification\noptions   ‚Äì algorithm options for solving the problem\nalgorithm ‚Äì (optional, default: dispatched on the system's type) the                reachability algorithm for the computation\n\nOutput\n\nA solution object whose content depends on the input options.\n\nNotes\n\nTo see all available input options, see keys(Reachability.available_keywords.dict).\n\n\n\n\n\nsolve(system::InitialValueProblem{<:HybridSystem},\n      options::Options)\n\nInterface to reachability algorithms for a hybrid system PWA dynamics.\n\nInput\n\nsystem  ‚Äì hybrid system\noptions ‚Äì options for solving the problem\n\n\n\n\n\n","category":"function"},{"location":"lib/transformations/#Transformations-1","page":"Transformations","title":"Transformations","text":"","category":"section"},{"location":"lib/transformations/#","page":"Transformations","title":"Transformations","text":"This module provides functions to apply coordinate transformations to Systems using matrix decompositions.","category":"page"},{"location":"lib/transformations/#","page":"Transformations","title":"Transformations","text":"Pages = [\"transformations.md\"]\nDepth = 3","category":"page"},{"location":"lib/transformations/#","page":"Transformations","title":"Transformations","text":"CurrentModule = Reachability.Utils","category":"page"},{"location":"lib/transformations/#Interface-1","page":"Transformations","title":"Interface","text":"","category":"section"},{"location":"lib/transformations/#","page":"Transformations","title":"Transformations","text":"This module exports a single function that works as an interface. It dispatches which transformation to apply using a string argument.","category":"page"},{"location":"lib/transformations/#","page":"Transformations","title":"Transformations","text":"transform","category":"page"},{"location":"lib/transformations/#Reachability.Utils.transform","page":"Transformations","title":"Reachability.Utils.transform","text":"transform(problem::InitialValueProblem, options::Options)\n\nInterface function that calls the respective transformation function.\n\nInput\n\nproblem ‚Äì discrete or continuous initial-value problem\noption  ‚Äì problem options\n\nOutput\n\nA tuple containing the transformed problem and the transformed options.\n\nNotes\n\nThe functions that are called in the background should return a the transformed system components A, X0, and U, and also an inverse transformation matrix M. If the system has an invariant, it is transformed as well.\n\n\n\n\n\n","category":"function"},{"location":"lib/transformations/#Schur-transform-1","page":"Transformations","title":"Schur transform","text":"","category":"section"},{"location":"lib/transformations/#","page":"Transformations","title":"Transformations","text":"The real Schur decomposition is of the form","category":"page"},{"location":"lib/transformations/#","page":"Transformations","title":"Transformations","text":"U^TAU = beginpmatrix\nT_11  T_12 cdots  T_1b \n0  T_22  cdots  T_2b \nvdots  vdots  ddots  vdots \n0  0  cdots  T_bb\nendpmatrix","category":"page"},{"location":"lib/transformations/#","page":"Transformations","title":"Transformations","text":"where T_ij are 2x2 matrices","category":"page"},{"location":"lib/transformations/#","page":"Transformations","title":"Transformations","text":"schur_transform","category":"page"},{"location":"lib/transformations/#Reachability.Utils.schur_transform","page":"Transformations","title":"Reachability.Utils.schur_transform","text":"schur_transform(problem::InitialValueProblem)\n\nApplies a Schur transformation to a discrete or continuous initial-value problem.\n\nInput\n\nproblem ‚Äì discrete or continuous initial-value problem\n\nOutput\n\nTransformed problem.\n\nAlgorithm\n\nWe use Julia's default schurfact function to compute a Schur decomposition of the coefficients matrix A.\n\n\n\n\n\n","category":"function"},{"location":"lib/transformations/#Examples-1","page":"Transformations","title":"Examples","text":"","category":"section"},{"location":"citations/#Citations-1","page":"Citations","title":"Citations","text":"","category":"section"},{"location":"citations/#","page":"Citations","title":"Citations","text":"Pages = [\"citations.md\"]","category":"page"},{"location":"citations/#","page":"Citations","title":"Citations","text":"This page lists publications citing JuliaReach, such as packages or papers from the JuliaReach ecosystem.","category":"page"},{"location":"citations/#Conference-Proceedings-1","page":"Citations","title":"Conference Proceedings","text":"","category":"section"},{"location":"citations/#","page":"Citations","title":"Citations","text":"Bogomolov, S., Frehse, G., Gurung, A., Li, D., Martius, G., & Ray, R. (2019). Falsification of hybrid systems using symbolic reachability and trajectory splicing. In Proceedings of HSCC'19: 22nd ACM International Conference on Hybrid Systems: Computation and Control (pp. 1-10). ACM.\nBak, Stanley, Hoang-Dung Tran, and Taylor T. Johnson. Numerical Verification of Affine Systems with up to a Billion Dimensions. arXiv preprint arXiv:1804.01583 (2018). Accepted in Proceedings of HSCC'19: 22nd ACM International Conference on Hybrid Systems: Computation and Control (HSCC'19).\nSchupp, Stefan, and Erika √Åbrah√°m. Spread the Work: Multi-threaded Safety Analysis for Hybrid Systems. International Conference on Software Engineering and Formal Methods. Springer, Cham, 2018.\nSchupp, Stefan, Justin Winkens, and Erika √Åbrah√°m. Context-Dependent Reachability Analysis for Hybrid Systems. 2018 IEEE International Conference on Information Reuse and Integration (IRI). IEEE, 2018.","category":"page"},{"location":"citations/#Journals-1","page":"Citations","title":"Journals","text":"","category":"section"},{"location":"citations/#","page":"Citations","title":"Citations","text":"Althoff, M. (2019). Reachability analysis of large linear systems with uncertain inputs in the Krylov subspace. IEEE Transactions on Automatic Control.","category":"page"},{"location":"citations/#Preprints-1","page":"Citations","title":"Preprints","text":"","category":"section"},{"location":"citations/#","page":"Citations","title":"Citations","text":"Roehm, H., Oehlerking, J., Woehrle, M., & Althoff, M. (2019). Model Conformance for Cyber-Physical Systems: A Survey. ACM Transactions on Cyber-Physical Systems, 3(3), 30.\nMinghui, S., Bakirtzis, G., Jafarzadeh, H., & Fleming, C. (2019). Correct-by-construction: a contract-based semi-automated requirement decomposition process. arXiv preprint arXiv:1909.02070.\nLiu, C., Arnon, T., Lazarus, C., Barrett, C., & Kochenderfer, M. J. (2019). Algorithms for Verifying Deep Neural Networks. arXiv preprint arXiv:1903.06758.\nJulian, K. D., & Kochenderfer, M. J. (2019). A Reachability Method for Verifying Dynamical Systems with Deep Neural Network Controllers. arXiv preprint arXiv:1903.00520.\nMitchell, Ian M., Jacob Budzis, and Andriy Bolyachevets. Invariant, Viability and Discriminating Kernel Under-Approximation via Zonotope Scaling. arXiv preprint arXiv:1901.01006 (2019).\nDang, T. (2019). Reachability Analysis and Hybrid Systems Biology - In Memoriam Oded Maler. In International Workshop on Hybrid Systems Biology (pp. 16-29). Springer, Cham.","category":"page"},{"location":"citations/#Technical-Reports-1","page":"Citations","title":"Technical Reports","text":"","category":"section"},{"location":"citations/#","page":"Citations","title":"Citations","text":"Report on compositional verification and incremental verification in interaction with online controller adaptation. Maria Prandini - PoliMi, Olaf Stursberg, Zonglin Liu - UKS, Goran Frehse - UGA, Matthias Althoff - TUM, Alexander Rausch, Jens Oehlerking - Bosch. Unifying Control and Verification of Cyber-Physical Systems (UnCoVerCPS)","category":"page"},{"location":"citations/#Theses-1","page":"Citations","title":"Theses","text":"","category":"section"},{"location":"citations/#","page":"Citations","title":"Citations","text":"Gupta, A. (2019). Safety verification of model based reinforcement learning controllers using reachability analysis. (Doctoral dissertation, Purdue University Graduate School).\nRocca, A. (2018). Formal methods for modelling and validation of biological models (Doctoral dissertation, Grenoble Alpes).\nSchilling, C. (2018). Fundamental techniques for the scalable analysis of systems.\nKekatos, N. (2018). Formal Verification of Cyber-Physical Systems in the Industrial Model-Based Design Process (Doctoral dissertation, Universit√© Grenoble Alpes).","category":"page"},{"location":"about/#About-1","page":"About","title":"About","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"This page contains some general information about this project, and recommendations about contributing.","category":"page"},{"location":"about/#","page":"About","title":"About","text":"Pages = [\"about.md\"]","category":"page"},{"location":"about/#Contributing-1","page":"About","title":"Contributing","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"If you like this package, consider contributing! We welcome bug reports, examples that can be added to the documentation, or new feature proposals.","category":"page"},{"location":"about/#","page":"About","title":"About","text":"Below some conventions that we follow when contributing to this package are detailed. For specific guidelines on documentation, see the Documentations Guidelines wiki.","category":"page"},{"location":"about/#Branches-1","page":"About","title":"Branches","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"Each pull request (PR) should be pushed in a new branch with the name of the author followed by a descriptive name, e.g. t/mforets/my_feature. If the branch is associated to a previous discussion in one issue, we use the name of the issue for easier lookup, e.g. t/mforets/7.","category":"page"},{"location":"about/#Unit-testing-and-continuous-integration-(CI)-1","page":"About","title":"Unit testing and continuous integration (CI)","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"This project is synchronized with Travis CI, such that each PR gets tested before merging (and the build is automatically triggered after each new commit). For the maintainability of this project, it is important to understand and fix the failing doctests if they exist. We develop in Julia v0.6.0, but for experimentation we also build on the nightly branch.","category":"page"},{"location":"about/#","page":"About","title":"About","text":"To run the unit tests locally, you should do:","category":"page"},{"location":"about/#","page":"About","title":"About","text":"$ julia --color=yes test/runtests.jl","category":"page"},{"location":"about/#Contributing-to-the-documentation-1","page":"About","title":"Contributing to the documentation","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"This documentation is written in Markdown, and it relies on Documenter.jl to produce the HTML layout. To build the docs, run make.jl:","category":"page"},{"location":"about/#","page":"About","title":"About","text":"$ julia --color=yes docs/make.jl","category":"page"},{"location":"about/#References-1","page":"About","title":"References","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"This repository was originally motivated by the mathematical approach described in Reach Set Approximation through Decomposition with Low-dimensional Sets and High-dimensional Matrices,  Sergiy Bogomolov, Marcelo Forets, Goran Frehse, Andreas Podelski, Christian Schilling, Fr√©d√©ric Viry, in 21st ACM International Conference on Hybrid Systems: Computation and Control, 2018 Edition (Porto, Portugal), see the arXiv pre-print here.","category":"page"},{"location":"about/#","page":"About","title":"About","text":"For a full references list of algorithms implemented in this repository, consult the References wiki.","category":"page"},{"location":"about/#Credits-1","page":"About","title":"Credits","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"Here we list the names of the contributors to Reachability.jl (in alphabetic order).","category":"page"},{"location":"about/#Core-developers-1","page":"About","title":"Core developers","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"Marcelo Forets\nChristian Schilling","category":"page"},{"location":"about/#Contributors-1","page":"About","title":"Contributors","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"Aadesh Deshmukh\nBruno Garate\nKostiantyn Potomkin\nMoritz Schauer\nFr√©d√©ric Viry","category":"page"},{"location":"about/#Collaborators-1","page":"About","title":"Collaborators","text":"","category":"section"},{"location":"about/#","page":"About","title":"About","text":"We are also grateful to the following persons for enlightening discussions: ","category":"page"},{"location":"about/#","page":"About","title":"About","text":"Sergiy Bogomolov\nGoran Frehse \nNikolaos Kekatos\nAndreas Podelski\nAlexandre Rocca","category":"page"},{"location":"lib/systems/#Systems-1","page":"Systems","title":"Systems","text":"","category":"section"},{"location":"lib/systems/#","page":"Systems","title":"Systems","text":"This module provides types to represent systems of affine ODEs in both discrete and continuous time.","category":"page"},{"location":"lib/systems/#","page":"Systems","title":"Systems","text":"Pages = [\"systems.md\"]\nDepth = 3","category":"page"},{"location":"lib/systems/#Types-of-systems-1","page":"Systems","title":"Types of systems","text":"","category":"section"},{"location":"lib/systems/#","page":"Systems","title":"Systems","text":"MathematicalSystems.jl provides some convenience types and methods to work with mathematical systems models. Every system inherits from AbstractSystem.","category":"page"},{"location":"lib/systems/#","page":"Systems","title":"Systems","text":"We support the following two concrete types of systems.","category":"page"},{"location":"lib/systems/#Discrete-system-1","page":"Systems","title":"Discrete system","text":"","category":"section"},{"location":"lib/systems/#","page":"Systems","title":"Systems","text":"A discrete system consists of a matrix representing the system dynamics, a set of initial states, a set of nondeterministic inputs, and a discretization step Œ¥.","category":"page"},{"location":"lib/systems/#Continuous-system-1","page":"Systems","title":"Continuous system","text":"","category":"section"},{"location":"lib/systems/#","page":"Systems","title":"Systems","text":"A continuous system consists of a matrix representing the system dynamics, a set of initial states, and a set of nondeterministic inputs.","category":"page"},{"location":"lib/systems/#Nondeterministic-inputs-1","page":"Systems","title":"Nondeterministic inputs","text":"","category":"section"},{"location":"lib/systems/#","page":"Systems","title":"Systems","text":"The above systems may contain nondeterministic inputs, which are wrapped in special types. Every nondeterministic input representation inherits from NonDeterministicInput.","category":"page"},{"location":"lib/systems/#","page":"Systems","title":"Systems","text":"The inputs are closely related to a DiscreteSystem in the sense that for each discrete time step the input set may change. We support iteration through the inputs over time.","category":"page"},{"location":"lib/systems/#Constant-nondeterministic-inputs-1","page":"Systems","title":"Constant nondeterministic inputs","text":"","category":"section"},{"location":"lib/systems/#","page":"Systems","title":"Systems","text":"Constant nondeterministic inputs are chosen from a set of values that does not change over time. Note that, while the set is constant, the inputs themselves vary over time.","category":"page"},{"location":"lib/systems/#Time-varying-nondeterministic-inputs-1","page":"Systems","title":"Time-varying nondeterministic inputs","text":"","category":"section"},{"location":"lib/systems/#","page":"Systems","title":"Systems","text":"Time-varying nondeterministic inputs are chosen from a set of values that changes over time (with each time step).","category":"page"},{"location":"lib/systems/#Normalization-1","page":"Systems","title":"Normalization","text":"","category":"section"},{"location":"lib/systems/#","page":"Systems","title":"Systems","text":"normalize","category":"page"},{"location":"lib/systems/#LinearAlgebra.normalize","page":"Systems","title":"LinearAlgebra.normalize","text":"normalize(system::AbstractSystem)\n\nTransform a mathematical system to a normalized (or canonical) form.\n\nInput\n\nsystem ‚Äì system; it can be discrete or continuous\n\nOutput\n\nEither the same system if it already conforms to a canonical form, or a new system otherwise.\n\nNotes\n\nThe normalization procedure consists of transforming a given system type into a \"canonical\" format that is used internally. More details are given below.\n\nAlgorithm\n\nThe implementation of normalize exploits MathematicalSystems's' types, which carry information about the problem as a type parameter.\n\nHomogeneous ODEs of the form x = Ax x  mathcalX are canonical if the associated problem is a ConstrainedLinearContinuousSystem and A is a matrix. This type does not handle non-deterministic inputs.\n\nNote that a LinearContinuousSystem does not consider constraints on the state-space (such as an invariant); to specify state constraints, use a ConstrainedLinearContinuousSystem. If the passed system is a LinearContinuousSystem (i.e. no constraints) then the normalization fixes a universal set (Universe) as the constraint set.\n\nThe generalization to canonical systems with constraints and possibly time-varying non-deterministic inputs is considered next. These systems are of the form x = Ax + u u  mathcalU x  mathcalX. The system type is ConstrainedLinearControlContinuousSystem, where A is a matrix, X is a set and U is an input, that is, any concrete subtype of AbstractInput.\n\nIf U is not given as an input, normalization accepts either a LazySet, or a vector of LazySets. In these cases, the sets are wrapped around an appropriate concrete input type.\n\nIf the system does not conform to a canonical form, the implementation tries to make the transformation; otherwise an error is thrown. In particular, ODEs of the form x = Ax + Bu are mapped into x = Ax + u u  BmathcalU, where now u has the same dimensions as x.\n\nThe transformations described above are analogous in the discrete case, i.e. x_k+1 = A x_k and x_k+1 = Ax_k + u_k u_k  mathcalU x_k  mathcalX for the linear and affine cases respectively.\n\n\n\n\n\n","category":"function"},{"location":"lib/algorithms/#Available-Algorithms-1","page":"Algorithms","title":"Available Algorithms","text":"","category":"section"},{"location":"lib/algorithms/#","page":"Algorithms","title":"Algorithms","text":"This section of the manual describes the algorithms that are available in this package.","category":"page"},{"location":"lib/algorithms/#","page":"Algorithms","title":"Algorithms","text":"Pages = [\"interface.md\"]","category":"page"},{"location":"lib/algorithms/#","page":"Algorithms","title":"Algorithms","text":"CurrentModule = Reachability.ReachSets","category":"page"},{"location":"lib/algorithms/#Continuous-time-reachability-1","page":"Algorithms","title":"Continuous-time reachability","text":"","category":"section"},{"location":"lib/algorithms/#Decomposition-based-approach-1","page":"Algorithms","title":"Decomposition-based approach","text":"","category":"section"},{"location":"lib/algorithms/#","page":"Algorithms","title":"Algorithms","text":"BFFPSV18","category":"page"},{"location":"lib/algorithms/#Reachability.ReachSets.BFFPSV18","page":"Algorithms","title":"Reachability.ReachSets.BFFPSV18","text":"BFFPSV18 <: ContinuousPost\n\nImplementation of the reachability algorithm for purely continuous linear time-invariant systems using block decompositons by S. Bogomolov, M. Forets, G. Frehse, A. Podelski, C. Schilling and F. Viry [1].\n\nFields\n\noptions ‚Äì an Options structure that holds the algorithm-specific options\n\nNotes\n\nThe following options are available:\n\noption :discretization of type String has default value 'forward'; model for bloating/continuous time analysis\noption :algorithm of type String has default value 'explicit'; algorithm backend\noption :Œ¥ of type Float64 with alias :sampling_time has default value '0.01'; time step\noption :vars of type AbstractArray{Int64,1} has default value 'Int64[]'; variables of interest; default: all variables\noption :partition of type AbstractArray{#s120,1} where #s120<:AbstractArray{Int64,1} has default value 'Array{Int64,1}[[]]'; block partition; a block is represented by a vector containing its indices\noption :sih_method of type String has default value 'concrete'; method to compute the symmetric interval hull in discretization\noption :exp_method of type String has default value 'base'; method to compute the matrix exponential\noption :assume_sparse of type Bool has default value 'false'; use an analysis for sparse discretized matrices?\noption :lazy_inputs_interval of type Union{Int64, Function} has default value 'getfield(Reachability.ReachSets, Symbol(\"##33#34\"))()'; length of interval in which the inputs are handled as a lazy set (``-1`` for 'never'); may generally also be a predicate over indices; the default corresponds to ``-1``\noption :block_options of type Any has default value 'nothing'; short hand to set ':block_options_init' and ':block_options_iter'\noption :block_options_init of type Any has default value 'nothing'; option for the approximation of the initial states (during decomposition)\noption :block_options_iter of type Any has default value 'nothing'; option for the approximation of the states ``X_k``, ``k>0``\noption :assume_homogeneous of type Bool has default value 'false'; ignore dynamic inputs during the analysis?\noption :eager_checking of type Bool has default value 'true'; terminate as soon as property violation was detected?\n\n\nAlgorithm\n\nWe refer to [1] for technical details.\n\n[1] Reach Set Approximation through Decomposition with Low-dimensional Sets and High-dimensional Matrices. S. Bogomolov, M. Forets, G. Frehse, A. Podelski, C. Schilling, F. Viry. HSCC '18 Proceedings of the 21st International Conference on Hybrid Systems: Computation and Control (part of CPS Week).\n\n\n\n\n\n","category":"type"},{"location":"lib/properties/#Properties-1","page":"Properties","title":"Properties","text":"","category":"section"},{"location":"lib/properties/#","page":"Properties","title":"Properties","text":"This module provides representations of (safety) properties.","category":"page"},{"location":"lib/properties/#","page":"Properties","title":"Properties","text":"Pages = [\"properties.md\"]\nDepth = 3","category":"page"},{"location":"lib/properties/#","page":"Properties","title":"Properties","text":"CurrentModule = Reachability.Properties","category":"page"},{"location":"lib/properties/#General-property-interface-1","page":"Properties","title":"General property interface","text":"","category":"section"},{"location":"lib/properties/#","page":"Properties","title":"Properties","text":"Property","category":"page"},{"location":"lib/properties/#Reachability.Properties.Property","page":"Properties","title":"Reachability.Properties.Property","text":"Abstract supertype of properties that can be checked.\n\nEvery concrete subtype should provide the following functions:\n\ndim(ùëÉ::Property)::Int\ncheck(ùëÉ::Property, X::LazySet; witness::Bool=false)\n\n\n\n\n\n","category":"type"},{"location":"lib/properties/#Boolean-combination-of-properties-1","page":"Properties","title":"Boolean combination of properties","text":"","category":"section"},{"location":"lib/properties/#","page":"Properties","title":"Properties","text":"Conjunction\ndim(::Conjunction)\ncheck(::Conjunction, ::LazySet{N}) where {N<:Real}\nDisjunction\ndim(::Disjunction)\ncheck(::Disjunction, ::LazySet{N}) where {N<:Real}","category":"page"},{"location":"lib/properties/#Reachability.Properties.Conjunction","page":"Properties","title":"Reachability.Properties.Conjunction","text":"Conjunction <: Property\n\nType that represents a conjunction of properties.\n\nFields\n\nconjuncts ‚Äì vector of properties\n\nNotes\n\nThe following formula characterizes whether a set X satisfies a disjunction ùëÉ = ùëÉ_1  ùëÉ_2    ùëÉ_m:\n\n    X models ùëÉ iff X models ùëÉ_j text for all  1  j  m\n\n\n\n\n\n","category":"type"},{"location":"lib/properties/#LazySets.dim-Tuple{Conjunction}","page":"Properties","title":"LazySets.dim","text":"dim(ùëÉ::Conjunction)::Int\n\nReturn the dimension of a conjunction of properties.\n\nInput\n\nùëÉ ‚Äì conjunction of properties\n\nOutput\n\nThe dimension of the conjunction of properties.\n\n\n\n\n\n","category":"method"},{"location":"lib/properties/#Reachability.Properties.check-Union{Tuple{N}, Tuple{Conjunction,LazySet{N}}} where N<:Real","page":"Properties","title":"Reachability.Properties.check","text":"check(ùëÉ::Conjunction, X::LazySet{N}; witness::Bool=false) where {N<:Real}\n\nCheck whether a convex set satisfies a conjunction of properties.\n\nInput\n\nùëÉ       ‚Äì conjunction of properties\nX       ‚Äì convex set\nwitness ‚Äì (optional, default: false) flag for returning a counterexample              if the property is violated\n\nOutput\n\nIf witness option is deactivated: true iff X satisfies the property ùëÉ\nIf witness option is activated:\n(true, []) iff X satisfies the property ùëÉ\n(false, v) iff X does not satisfy the property ùëÉ with witness v\n\nNotes\n\nBy convention, the empty conjunction is equivalent to true and hence is satisfied by any set.\n\n\n\n\n\n","category":"method"},{"location":"lib/properties/#Reachability.Properties.Disjunction","page":"Properties","title":"Reachability.Properties.Disjunction","text":"Disjunction <: Property\n\nType that represents a disjunction of properties.\n\nFields\n\ndisjuncts ‚Äì vector of properties (elements are reordered by this type)\nreorder   ‚Äì flag to indicate whether shuffling is allowed\n\nNotes\n\nThe following formula characterizes whether a set X satisfies a disjunction ùëÉ = ùëÉ_1  ùëÉ_2    ùëÉ_m:\n\n    X models ùëÉ iff X models ùëÉ_j text for some  1  j  m\n\nIf the reorder flag is set, the disjuncts may be reordered after each call to check as a heuristics to make subsequent checks faster.\n\n\n\n\n\n","category":"type"},{"location":"lib/properties/#LazySets.dim-Tuple{Disjunction}","page":"Properties","title":"LazySets.dim","text":"dim(ùëÉ::Disjunction)::Int\n\nReturn the dimension of a disjunction of properties.\n\nInput\n\nùëÉ ‚Äì disjunction of properties\n\nOutput\n\nThe dimension of the disjunction of properties.\n\n\n\n\n\n","category":"method"},{"location":"lib/properties/#Reachability.Properties.check-Union{Tuple{N}, Tuple{Disjunction,LazySet{N}}} where N<:Real","page":"Properties","title":"Reachability.Properties.check","text":"check(ùëÉ::Disjunction, X::LazySet{N}; witness::Bool=false) where {N<:Real}\n\nCheck whether a convex set satisfies a disjunction of properties.\n\nInput\n\nùëÉ       ‚Äì disjunction of properties\nX       ‚Äì convex set\nwitness ‚Äì (optional, default: false) flag for returning a counterexample              if the property is violated\n\nOutput\n\nIf witness option is deactivated: true iff X satisfies the property ùëÉ\nIf witness option is activated:\n(true, []) iff X satisfies the property ùëÉ\n(false, v) iff X does not satisfy the property ùëÉ with witness v; note that v == N[] if ùëÉ is the empty disjunction\n\nNotes\n\nBy convention, the empty disjunction is equivalent to false and hence is satisfied by no set.\n\nIf the ùëÉ.reorder flag is set, the disjuncts may be reordered as a heuristics to make subsequent checks faster. Since we check satisfaction from left to right, we move the disjunct for which satisfaction was established to the front.\n\nTo be consistent with other propertes, the witness option only returns one counterexample, namely for the left-most disjunct in the disjuncts vector. We deactivate witness production for checking the remaining disjuncts.\n\n\n\n\n\n","category":"method"},{"location":"lib/properties/#Specific-properties-1","page":"Properties","title":"Specific properties","text":"","category":"section"},{"location":"lib/properties/#","page":"Properties","title":"Properties","text":"SafeStatesProperty\ndim(::SafeStatesProperty)\ncheck(::SafeStatesProperty, ::LazySet)\nBadStatesProperty\ndim(::BadStatesProperty)\ncheck(::BadStatesProperty, ::LazySet)","category":"page"},{"location":"lib/properties/#Reachability.Properties.SafeStatesProperty","page":"Properties","title":"Reachability.Properties.SafeStatesProperty","text":"SafeStatesProperty{N<:Real} <: Property\n\nType that represents a safety property characterized by a set of safe states. The property is satisfied by a given set of states X if X is fully contained in the set of safe states.\n\nFields\n\nsafe    ‚Äì convex set representing the safe states\nwitness ‚Äì witness point (empty vector if not set)\n\nNotes\n\nThe following formula characterizes whether a set X satisfies a safety property characterized by a set of safe states ùëÉ:\n\n    X models ùëÉ iff X  ùëÉtextttsafe\n\n\n\n\n\n","category":"type"},{"location":"lib/properties/#LazySets.dim-Tuple{SafeStatesProperty}","page":"Properties","title":"LazySets.dim","text":"dim(ùëÉ::SafeStatesProperty)::Int\n\nReturn the dimension of a property with safe states.\n\nInput\n\nùëÉ ‚Äì safety property with safe states\n\nOutput\n\nThe dimension of the safe states.\n\n\n\n\n\n","category":"method"},{"location":"lib/properties/#Reachability.Properties.check-Tuple{SafeStatesProperty,LazySet}","page":"Properties","title":"Reachability.Properties.check","text":"check(ùëÉ::SafeStatesProperty, X::LazySet; witness::Bool=false)\n\nChecks whether a convex set is contained in the set of safe states.\n\nInput\n\nùëÉ       ‚Äì safety property with safe states\nX       ‚Äì convex set\nwitness ‚Äì (optional, default: false) flag for returning a counterexample              if the property is violated\n\nOutput\n\nLet Y be the safe states represented by ùëÉ.\n\nIf witness option is deactivated: true iff X  Y\nIf witness option is activated:\n(true, []) iff X  Y\n(false, v) iff X  Y and v  X setminus Y\n\n\n\n\n\n","category":"method"},{"location":"lib/properties/#Reachability.Properties.BadStatesProperty","page":"Properties","title":"Reachability.Properties.BadStatesProperty","text":"BadStatesProperty{N<:Real} <: Property\n\nType that represents a safety property characterized by a set of bad states. The property is satisfied by a given set of states if the intersection with the set of bad states is empty.\n\nFields\n\nbad     ‚Äì convex set representing the bad states\nwitness ‚Äì witness point (empty vector if not set)\n\nNotes\n\nThe following formula characterizes whether a set X satisfies a safety property characterized by a set of bad states ùëÉ:\n\n    X models ùëÉ iff X  ùëÉtextttbad = \n\n\n\n\n\n","category":"type"},{"location":"lib/properties/#LazySets.dim-Tuple{BadStatesProperty}","page":"Properties","title":"LazySets.dim","text":"dim(ùëÉ::BadStatesProperty)::Int\n\nReturn the dimension of a property with bad states.\n\nInput\n\nùëÉ ‚Äì safety property with bad states\n\nOutput\n\nThe dimension of the bad states.\n\n\n\n\n\n","category":"method"},{"location":"lib/properties/#Reachability.Properties.check-Tuple{BadStatesProperty,LazySet}","page":"Properties","title":"Reachability.Properties.check","text":"check(ùëÉ::BadStatesProperty, X::LazySet; witness::Bool=false)\n\nChecks whether a convex set is disjoint from the set of bad states.\n\nInput\n\nùëÉ       ‚Äì safety property with bad states\nX       ‚Äì convex set\nwitness ‚Äì (optional, default: false) flag for returning a counterexample              if the property is violated\n\nOutput\n\nLet Y be the bad states represented by ùëÉ.\n\nIf witness option is deactivated: true iff X  Y = \nIf witness option is activated:\n(true, []) iff X  Y = \n(false, v) iff X  Y   and v  X  Y\n\n\n\n\n\n","category":"method"},{"location":"lib/distributed/#Distributed-computations-1","page":"Distributed computations","title":"Distributed computations","text":"","category":"section"},{"location":"lib/distributed/#","page":"Distributed computations","title":"Distributed computations","text":"This section of the manual describes functions to make use of distributed computation.","category":"page"},{"location":"lib/distributed/#","page":"Distributed computations","title":"Distributed computations","text":"Pages = [\"distributed.md\"]","category":"page"},{"location":"lib/distributed/#","page":"Distributed computations","title":"Distributed computations","text":"CurrentModule = Reachability","category":"page"},{"location":"lib/distributed/#Using-multiple-threads-1","page":"Distributed computations","title":"Using multiple threads","text":"","category":"section"},{"location":"lib/distributed/#","page":"Distributed computations","title":"Distributed computations","text":"To control the number of threads used by your BLAS library, use the function Base.LinAlg.BLAS.set_num_threads(n), where n is an integer. Furthermore, the function get_num_threads() defined below will return the current value.","category":"page"},{"location":"lib/distributed/#","page":"Distributed computations","title":"Distributed computations","text":"Note. If you are using Julia v\"0.7-\" (run the command VERSION to find this), instead of Base.LinAlg below use LinearAlgebra, and this module should have been loaded in the current scope with using LinearAlgebra.","category":"page"},{"location":"lib/distributed/#","page":"Distributed computations","title":"Distributed computations","text":"#\n# This function is a part of Julia. License is MIT: https://julialang.org/license\n#\nfunction get_num_threads() # anonymous so it will be serialized when called\n    blas = Base.LinAlg.BLAS.vendor()\n    # Wrap in a try to catch unsupported blas versions\n    try\n        if blas == :openblas\n            return ccall((:openblas_get_num_threads, Base.libblas_name), Cint, ())\n        elseif blas == :openblas64\n            return ccall((:openblas_get_num_threads64_, Base.libblas_name), Cint, ())\n        elseif blas == :mkl\n            return ccall((:MKL_Get_Max_Num_Threads, Base.libblas_name), Cint, ())\n        end\n\n        # OSX BLAS looks at an environment variable\n        if Sys.isapple()\n            return ENV[\"VECLIB_MAXIMUM_THREADS\"]\n        end\n    end\n\n    return nothing\nend","category":"page"},{"location":"#Reachability.jl-1","page":"Home","title":"Reachability.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Reachability is a Julia package for approximating the reachable states and checking safety properties of affine systems.","category":"page"},{"location":"#Reachable-states-approximation-1","page":"Home","title":"Reachable states approximation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"In a nutshell, we overapproximate the reachable states of an affine system by solving a set-based recurrence. The key idea is that we first decompose the system into (low-dimensional) subsystems and later compose the results as a Cartesian product. Thus we have to solve many cheap problems instead of one hard problem. Since solving the recurrence scales superlinearly with the dimension, this approach is very scalable.","category":"page"},{"location":"#Decomposition-error-1","page":"Home","title":"Decomposition error","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Decomposition typically involves a loss in precision, and so does this approach. The good thing is that we can decompose the recurrence as well, which allows us to analyze each of the subsystems independently by only referring to the initial states of the other subsystems. Consequently, there are two main sources for precision loss:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Decomposition of the initial states: If two subsystems are interdependent initially.\nRepresentation of the reachable states as a Cartesian product: If two subsystems are interdependent in the dynamics.\nRepresentation of the reachable states in general: The reachable states of affine systems cannot be represented precisely in all cases. This is a problem that all approaches suffer from. We overapproximate the reachable states by (unions of) convex polytopes.","category":"page"},{"location":"#Checking-safety-properties-1","page":"Home","title":"Checking safety properties","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The problem of checking a safety property can be reduced to a reachability problem. We provide special support for this reduction by inlining the property check into the reachable states computation. This has two benefits:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"We fail fast when the property is violated in our abstraction.\nThe check is usually cheaper than computing the full reachable states. This is because we are often only interested in an upper or lower bound of a variable.","category":"page"},{"location":"#Lazy-sets-1","page":"Home","title":"Lazy sets","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"To represent sets of states, we use the LazySets package which provides exact but lazy (i.e. symbolic) representations of common sets.","category":"page"},{"location":"#Library-outline-1","page":"Home","title":"Library outline","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Pages = [\n    \"lib/interface.md\",\n    \"lib/systems.md\",\n    \"lib/algorithms.md\",\n    \"lib/transformations.md\",\n    \"lib/discretize.md\",\n    \"lib/distributed.md\"\n]\nDepth = 2","category":"page"},{"location":"lib/discretize/#Discretize-1","page":"Discretization","title":"Discretize","text":"","category":"section"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"Pages = [\"discretize.md\"]\nDepth = 3","category":"page"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"CurrentModule = Reachability.ReachSets","category":"page"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"discretize\ndiscretize_interpolation\ndiscretize_firstorder\ndiscretize_nobloating\ndiscretize_interval_matrix","category":"page"},{"location":"lib/discretize/#Reachability.ReachSets.discretize","page":"Discretization","title":"Reachability.ReachSets.discretize","text":"discretize(ùëÜ, Œ¥; [algorithm], [exp_method], [sih_method], [set_operations])\n\nApply an approximation model to S obtaining a discrete initial value problem.\n\nInput\n\nùëÜ             ‚Äì initial value problem for a continuous affine ODE with                    non-deterministic inputs\nŒ¥             ‚Äì step size\nalgorithm     ‚Äì (optional, default: \"forward\") the algorithm used to                    compute the approximation model for the discretization;                    choose among:\n\"forward\"    ‚Äì use forward-time interpolation\n\"backward\"   ‚Äì use backward-time interpolation\n\"firstorder\" ‚Äì use first-order approximation of the ODE\n\"nobloating\" ‚Äì do not bloat the initial states\nexp_method  ‚Äì (optional, default: \"base\") the method used to take the matrix                   exponential of the coefficient matrix; choose among:\n\"base\" ‚Äì the scaling and squaring method implemented in Julia base,             see ?exp for details\n\"pade\" ‚Äì use Pade approximant method to compute matrix exponentials of             sparse matrices, implemented in Expokit\n\"lazy\" ‚Äì compute a wrapper type around the matrix exponential, i.e. using             the lazy implementation SparseMatrixExp from LazySets and             the evaluation of the action of the matrix exponential using the             expmv implementation from Expokit\nsih_method  ‚Äì (optional, default: \"concrete\") the method used to take the                   symmetric interval hull operation; choose among:\n\"concrete\" ‚Äì compute the full symmetric interval hull using the function                 symmetric_interval_hull from LazySets.Approximations\n\"lazy\"     ‚Äì compute a wrapper set type around symmetric interval hull                 in a lazy way using SymmetricIntervalHull\nset_operations  ‚Äì (optional, default: \"lazy\") set operations used for the                      discretized initial states and transformed inputs; choose                      among:\n\"lazy\"     ‚Äì use lazy convex hull for the initial states and lazy linear                 map for the inputs\n\"zonotope\" ‚Äì use concrete zonotope operations (linear map and Minkowski sum)                 and return zonotopes for both the initial states and the                 inputs of the discretized system\n\nOutput\n\nThe initial value problem of a discrete system.\n\nAlgorithm\n\nLet ùëÜ  x = Ax(t) + u(t), x(0)  mathcalX_0, u(t)  U be the given continuous affine ODE ùëÜ, where U is the set of non-deterministic inputs and mathcalX_0 is the set of initial states. Recall that the system ùëÜ is called homogeneous whenever U is the empty set.\n\nGiven a step size Œ¥, this function computes a set, Œ©‚ÇÄ, that guarantees to contain all the trajectories of ùëÜ starting at any x(0)  mathcalX_0 and for any input function that satisfies u(t)  U, for any t  0 Œ¥.\n\nThe initial value problem returned by this function consists of the set Œ©‚ÇÄ together with the coefficient matrix œï = e^AŒ¥ and a transformed set of inputs if U is non-empty.\n\nIn the literature, the method to obtain Œ©‚ÇÄ is called the approximation model and different alternatives have been proposed. See the argument algorithm for available options. For the reference to the original papers, see the docstring of each method discretize_....\n\nIn the dense-time case, the transformation is such that the trajectories of the given continuous system are included in the computed flowpipe of the discretized system.\n\nIn the discrete-time case, there is no bloating of the initial states and the input is assumed to remain constant between sampled times. Use the option algorithm=\"nobloating\" for this setting.\n\nSeveral methods to compute the matrix exponential are availabe. Use exp_method to select one. For very large systems, computing the full matrix exponential is expensive hence it is preferable to compute the action of the matrix exponential over vectors when needed, e^{Œ¥A} v for each v. Use the option exp_method=\"lazy\" for this purpose.\n\n\n\n\n\n","category":"function"},{"location":"lib/discretize/#Reachability.ReachSets.discretize_interpolation","page":"Discretization","title":"Reachability.ReachSets.discretize_interpolation","text":"discretize_interpolation(ùëÜ, Œ¥; [algorithm], [exp_method], [sih_method])\n\nCompute bloating factors using forward or backward interpolation.\n\nInput\n\nùëÜ             ‚Äì a continuous system\nŒ¥             ‚Äì step size\nalgorithm     ‚Äì choose the algorithm to compute the approximation model                    among \"forward\" and \"backward\"\nexp_method    ‚Äì (optional, default: \"base\") the method used to take the matrix                    exponential of the coefficient matrix; choose among:\n\"base\" ‚Äì the scaling and squaring method implemented in Julia base,             see ?exp for details\n\"pade\" ‚Äì use Pade approximant method to compute matrix exponentials of             sparse matrices, implemented in Expokit\n\"lazy\" ‚Äì compute a wrapper type around the matrix exponential, i.e. using             the lazy implementation SparseMatrixExp from LazySets and             the evaluation of the action of the matrix exponential using the             expmv implementation from Expokit\nsih_method    ‚Äì (optional, default: \"concrete\") the method used to take the                    symmetric interval hull operation; choose among:\n\"concrete\" ‚Äì compute the full symmetric interval hull\n\"lazy\"     ‚Äì compute a wrapper set type around symmetric interval hull in a                 lazy way\nset_operations ‚Äì (optional, default: \"lazy\") set operations used for the                     discretized initial states and transformed inputs; choose                     among:\n\"lazy\"     ‚Äì use lazy convex hull for the initial states and lazy                 linear map for the inputs\n\"zonotope\" ‚Äì use concrete zonotope operations (linear map and Minkowski                 sum) and return zonotopes for both the initial states and                 the inputs of the discretized system\n\nOutput\n\nThe initial value problem for a discrete system. In particular:\n\nif the input system is homogeneous, a LinearDiscreteSystem is returned,\notherwise a ConstrainedLinearControlDiscreteSystem is returned.\n\nAlgorithm\n\nLet us define some notation. Let\n\nùëÜ  x = Ax(t) + u(t)\n\nwith x(0)  mathcalX_0, u(t)  U be the given continuous affine ODE ùëÜ, where U is the set of non-deterministic inputs and mathcalX_0 is the set of initial states.\n\nThe transformations are:\n\nŒ¶  exp^AŒ¥,\nŒ©‚ÇÄ  ConvexHull(mathcalX_0 Œ¶mathcalX_0  Œ¥U(0)  Eœà(U(0) Œ¥)  E^+(mathcalX_0 Œ¥)),\nV  Œ¥U(k)  Eœà(U(k) Œ¥).\n\nHere we allow U to be a sequence of time varying non-deterministic input sets.\n\nFor the definition of the sets Eœà and E^+ see [1]. The  \"backward\" method uses E^-.\n\n[1] Frehse, Goran, et al. \"SpaceEx: Scalable verification of hybrid systems.\" International Conference on Computer Aided Verification. Springer, Berlin, Heidelberg, 2011.\n\n\n\n\n\n","category":"function"},{"location":"lib/discretize/#Reachability.ReachSets.discretize_firstorder","page":"Discretization","title":"Reachability.ReachSets.discretize_firstorder","text":"discretize_firstorder(ùëÜ, Œ¥; [p], [exp_method])\n\nApply a first-order approximation model to S obtaining a discrete initial value problem.\n\nInput\n\nùëÜ           ‚Äì initial value problem for a continuous affine ODE with                  non-deterministic inputs\nŒ¥           ‚Äì step size\np           ‚Äì (optional, default: Inf) parameter in the considered norm\nexp_method  ‚Äì (optional, default: \"base\") the method used to take the matrix                   exponential of the coefficient matrix; choose among:\n\"base\" ‚Äì the scaling and squaring method implemented in Julia base,             see ?exp for details\n\"pade\" ‚Äì use Pade approximant method to compute matrix exponentials of             sparse matrices, implemented in Expokit\n\"lazy\" ‚Äì compute a wrapper type around the matrix exponential, i.e. using             the lazy implementation SparseMatrixExp from LazySets and             the evaluation of the action of the matrix exponential using the             expmv implementation from Expokit\n\nOutput\n\nThe initial value problem for a discrete system. In particular:\n\nif the input system is homogeneous, a LinearDiscreteSystem is returned,\notherwise a ConstrainedLinearControlDiscreteSystem is returned.\n\nAlgorithm\n\nLet us define some notation. Let\n\nùëÜ  x = Ax(t) + u(t)\n\nwith x(0)  mathcalX_0, u(t)  U be the given continuous affine ODE ùëÜ, where U is the set of non-deterministic inputs and mathcalX_0 is the set of initial states.\n\nDefine R_mathcalX_0 = max_x  mathcalX_0 x, D_{\\mathcal{X}_0} = \\max_{x, y ‚àà \\mathcal{X}_0} ‚Äñx-y‚ÄñandR_{U} = \\max_{u ‚àà U} ‚Äñu‚Äñ. If only the support functions of\\mathcal{X}_0andUare known, these values might be hard to compute for some norms. SeeNotes` below for details.\n\nLet Œ©‚ÇÄ be the set defined as:\n\nŒ©‚ÇÄ = ConvexHull(mathcalX_0 e^Œ¥AmathcalX_0  Œ¥U  Œ±B_p)\n\nwhere Œ± = (e^Œ¥ A - 1 - Œ¥A)*(R_mathcalX_0 + R_U  A) and B_p denotes the unit ball for the considered p-norm.\n\nIt is proved in [Lemma 1, 1] that the set of states reachable by S in the time interval 0 Œ¥, which we denote R_0Œ¥(mathcalX_0) here, is included in Œ©‚ÇÄ:\n\nR_0Œ¥(mathcalX_0)  Œ©‚ÇÄ\n\nMoreover, if d_H(A B) denotes the Hausdorff distance between the sets A and B in mathbbR^n, then\n\nd_H(Œ©‚ÇÄ R_0Œ¥(mathcalX_0))  frac14(e^Œ¥ A - 1) D_mathcalX_0 + 2Œ±\n\nHence, the approximation error can be made arbitrarily small by choosing Œ¥ small enough.\n\nHere we allow U to be a sequence of time varying non-deterministic inputs.\n\nNotes\n\nIn this implementation, the infinity norm is used by default. Other usual norms are p=1 and p=2. However, note that not all norms are supported; see the documentation of ?norm in LazySets for the supported norms.\n\nSee also discretize_interpolation for an alternative algorithm that uses less conservative bounds.\n\n[1] Le Guernic, C., & Girard, A., 2010, Reachability analysis of linear systems using support functions. Nonlinear Analysis: Hybrid Systems, 4(2), 250-262.\n\n\n\n\n\n","category":"function"},{"location":"lib/discretize/#Reachability.ReachSets.discretize_nobloating","page":"Discretization","title":"Reachability.ReachSets.discretize_nobloating","text":"discretize_nobloating(ùëÜ, Œ¥; [exp_method])\n\nDiscretize a continuous system without bloating of the initial states, suitable for discrete-time reachability.\n\nInput\n\nùëÜ          ‚Äì a continuous system\nŒ¥          ‚Äì step size\nexp_method ‚Äì (optional, default: \"base\") the method used to take the matrix                 exponential of the coefficient matrix; choose among:\n\"base\" ‚Äì the scaling and squaring method implemented in Julia base,             see ?exp for details\n\"pade\" ‚Äì use Pade approximant method to compute matrix exponentials of             sparse matrices, implemented in Expokit\n\"lazy\" ‚Äì compute a wrapper type around the matrix exponential, i.e. using             the lazy implementation SparseMatrixExp from LazySets and             the evaluation of the action of the matrix exponential using the             expmv implementation from Expokit\n\nOutput\n\nThe initial value problem for a discrete system. In particular:\n\nif the input system is homogeneous, a LinearDiscreteSystem is returned,\notherwise a ConstrainedLinearControlDiscreteSystem is returned.\n\nAlgorithm\n\nLet us define some notation. Let\n\nùëÜ  x = Ax(t) + u(t)\n\nwith x(0)  mathcalX_0, u(t)  U be the given continuous affine ODE ùëÜ, where U is the set of non-deterministic inputs and mathcalX_0 is the set of initial states.\n\nThe approximation model implemented in this function is such that there is no bloating, i.e. we don't bloat the initial states and don't multiply the input by the step size Œ¥, as required for the dense time case.\n\nThe transformations are:\n\nŒ¶  exp^AŒ¥\nŒ©‚ÇÄ  mathcalX_0\nV  Œ¶‚ÇÅ(A Œ¥)U(k), where Œ¶‚ÇÅ(A Œ¥) is defined in Œ¶‚ÇÅ.\n\nHere we allow U to be a sequence of time varying non-deterministic input sets.\n\n\n\n\n\n","category":"function"},{"location":"lib/discretize/#Reachability.ReachSets.discretize_interval_matrix","page":"Discretization","title":"Reachability.ReachSets.discretize_interval_matrix","text":"discretize_interval_matrix(ùëÜ::InitialValueProblem, Œ¥::Float64, order::Int)\n\nDiscretize an affine continuous system whose dynamics are described by an interval matrix.\n\nInput\n\nùëÜ              ‚Äì a continuous system\nŒ¥              ‚Äì step size\norder          ‚Äì order for Taylor-series approximation, ‚â• 2\nset_operations ‚Äì (optional, default: \"zonotope\") set operations used for                     the discretized initial states and transformed inputs;                     choose among:\n\"lazy\"     ‚Äì use lazy convex hull for the initial states and lazy                 linear map for the inputs\n\"zonotope\" ‚Äì use concrete zonotope operations (linear map and Minkowski                 sum) and return zonotopes for both the initial states and                 the inputs of the discretized system\n\nOutput\n\nThe discretized system. In particular:\n\nif the input system is homogeneous, a LinearDiscreteSystem is returned,\notherwise a ConstrainedLinearControlDiscreteSystem is returned.\n\nAlgorithm\n\nSee the first two lines of Algorithm 1 in [1].\n\n[1] M. Althoff, O. Stursberg, M. Buss. Reachability Analysis of Linear Systems with Uncertain Parameters and Inputs. CDC 2007.\n\n\n\n\n\n","category":"function"},{"location":"lib/discretize/#Helper-functions-1","page":"Discretization","title":"Helper functions","text":"","category":"section"},{"location":"lib/discretize/#","page":"Discretization","title":"Discretization","text":"exp_AŒ¥\nŒ¶‚ÇÅ\nŒ¶‚ÇÇ","category":"page"},{"location":"lib/discretize/#Reachability.ReachSets.exp_AŒ¥","page":"Discretization","title":"Reachability.ReachSets.exp_AŒ¥","text":"exp_AŒ¥(A::AbstractMatrix, Œ¥::Float64; [exp_method])\n\nCompute the matrix exponential e^AŒ¥.\n\nInput\n\nA           ‚Äì coefficient matrix\nŒ¥           ‚Äì step size\nexp_method  ‚Äì (optional, default: \"base\") the method used to take the matrix                   exponential of the coefficient matrix; choose among:\n\"base\" ‚Äì the scaling and squaring method implemented in Julia base,             see ?exp for details\n\"pade\" ‚Äì use Pade approximant method to compute matrix exponentials of             sparse matrices, implemented in Expokit\n\"lazy\" ‚Äì compute a wrapper type around the matrix exponential, i.e. using             the lazy implementation SparseMatrixExp from LazySets and             the evaluation of the action of the matrix exponential using the             expmv implementation from Expokit\n\nOutput\n\nA matrix.\n\n\n\n\n\n","category":"function"},{"location":"lib/discretize/#Reachability.ReachSets.Œ¶‚ÇÅ","page":"Discretization","title":"Reachability.ReachSets.Œ¶‚ÇÅ","text":"Œ¶‚ÇÅ(A, Œ¥; [exp_method])\n\nCompute the series\n\nŒ¶‚ÇÅ(A Œ¥) = _i=0^ dfracŒ¥^i+1(i+1)A^i\n\nwhere A is a square matrix of order n and Œ¥  mathbbR_0.\n\nInput\n\nA           ‚Äì coefficient matrix\nŒ¥           ‚Äì step size\nexp_method  ‚Äì (optional, default: \"base\") the method used to take the matrix                   exponential of the coefficient matrix; choose among:\n\"base\" ‚Äì the scaling and squaring method implemented in Julia base,             see ?exp for details\n\"pade\" ‚Äì use Pade approximant method to compute matrix exponentials of             sparse matrices, implemented in Expokit\n\"lazy\" ‚Äì compute a wrapper type around the matrix exponential, i.e. using             the lazy implementation SparseMatrixExp from LazySets and             the evaluation of the action of the matrix exponential using the             expmv implementation from Expokit\n\nOutput\n\nA matrix.\n\nAlgorithm\n\nWe use the method from [1]. If A is invertible, Œ¶‚ÇÅ can be computed as\n\nŒ¶‚ÇÅ(A Œ¥) = A^-1(e^Œ¥A - I_n)\n\nIn the general case, implemented in this function, it can be computed as submatrices of the block matrix\n\nP = exp beginpmatrix\nAŒ¥  Œ¥I_n  0 \n0  0  Œ¥I_n \n0  0  0\nendpmatrix\n\nIt can be shown that Œ¶‚ÇÅ(A, Œ¥) = P[1:n, (n+1):2*n].\n\n[1] Frehse, Goran, et al. \"SpaceEx: Scalable verification of hybrid systems.\" International Conference on Computer Aided Verification. Springer, Berlin, Heidelberg, 2011.\n\n\n\n\n\n","category":"function"},{"location":"lib/discretize/#Reachability.ReachSets.Œ¶‚ÇÇ","page":"Discretization","title":"Reachability.ReachSets.Œ¶‚ÇÇ","text":"Œ¶‚ÇÇ(A, Œ¥; [exp_method])\n\nCompute the series\n\nŒ¶‚ÇÇ(A Œ¥) = _i=0^ dfracŒ¥^i+2(i+2)A^i\n\nwhere A is a square matrix of order n and Œ¥  mathbbR_0.\n\nInput\n\nA           ‚Äì coefficient matrix\nŒ¥           ‚Äì step size\nexp_method  ‚Äì (optional, default: \"base\") the method used to take the matrix                   exponential of the coefficient matrix; choose among:\n\"base\" ‚Äì the scaling and squaring method implemented in Julia base,             see ?exp for details\n\"pade\" ‚Äì use Pade approximant method to compute matrix exponentials of             sparse matrices, implemented in Expokit\n\"lazy\" ‚Äì compute a wrapper type around the matrix exponential, i.e. using             the lazy implementation SparseMatrixExp from LazySets and             the evaluation of the action of the matrix exponential using the             expmv implementation from Expokit\n\nOutput\n\nA matrix.\n\nAlgorithm\n\nWe use the method from [1]. If A is invertible, Œ¶‚ÇÇ can be computed as\n\nŒ¶‚ÇÇ(A Œ¥) = A^-2(e^Œ¥A - I_n - Œ¥A)\n\nIn the general case, implemented in this function, it can be computed as submatrices of the block matrix\n\nP = exp beginpmatrix\nAŒ¥  Œ¥I_n  0 \n0  0  Œ¥I_n \n0  0  0\nendpmatrix\n\nIt can be shown that Œ¶‚ÇÇ(A, Œ¥) = P[1:n, (2*n+1):3*n].\n\n[1] Frehse, Goran, et al. \"SpaceEx: Scalable verification of hybrid systems.\" International Conference on Computer Aided Verification. Springer, Berlin, Heidelberg, 2011.\n\n\n\n\n\n","category":"function"}]
}
